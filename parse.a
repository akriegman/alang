```parse.rs
enum Val {
    Imm(i8),
    Reg(usize),
    Port(usize),
}

enum Inst<L> {
    Mv(Val, Val),
    Jez(Val, L),
}

pub struct Processor {
    program: Vec<Inst<usize>>,

    pc: usize,
    registers: Vec<i8>,
    ports: Vec<Port<i8>>,
}

pub fn Processor::parse(&mut self, asm: &str) -> Result<(), String> {
    let mut ir: Vec<Inst<&str>> = Vec::new();
    let mut labels = HashMap::new();

    for line in asm.lines() {
        let line = line.split('#').next().unwrap(); // split always returns at least one segment
        let mut words = line.split_whitespace().peekable();

        let Some(maybe_label) = words.peek() else {
            continue;
        };
        if maybe_label.ends_with(':') {
            let label = maybe_label.trim_end_matches(':');
            if let Some(_) = labels.insert(label, ir.len()) {
                return Err(format!("repeated label {label}"));
            }
            words.next();
        }

        let Some(opcode) = words.next() else { continue };

        let parse_src = |tok: Option<&str>| {
            let Some(tok) = tok else {
                return Err(format!("{opcode} expects another operand"));
            };

            if tok.starts_with("0b") {
                match u8::from_str_radix(&tok[2..], 2) {
                    Ok(val) => Ok(Val::Imm(val as i8)),
                    Err(err) => match err.kind() {
                        IntErrorKind::PosOverflow | IntErrorKind::NegOverflow => {
                            Err(format!("{tok} out of range"))
                        }
                        _ => Err(format!("invalid binary literal {tok}")),
                    },
                }
            } else if tok.starts_with("0x") {
                match u8::from_str_radix(&tok[2..], 16) {
                    Ok(val) => Ok(Val::Imm(val as i8)),
                    Err(err) => match err.kind() {
                        IntErrorKind::PosOverflow | IntErrorKind::NegOverflow => {
                            Err(format!("{tok} out of range"))
                        }
                        _ => Err(format!("invalid hex literal {tok}")),
                    },
                }
            } else if let Ok(val) = tok.parse::<i8>() {
                Ok(Val::Imm(val))
                // todo: distinguish between bad literal and non numeric
            } else if tok.starts_with("'") {
                if let Some(val) = tok.chars().nth(1).map(|c| c.as_ascii()).flatten() {
                    Ok(Val::Imm(Into::<u8>::into(val) as i8))
                } else {
                    Err(format!("invalid char literal {tok}"))
                }
                // todo: make this more restrictive
                // we probably don't want to allow 'abcd
                // we want to allow 'a or 'a'
                // we may want to allow both...
            } else if let Some(idx) = self.register_names.iter().position(|name| name == tok) {
                Ok(Val::Reg(idx))
            } else if let Some(idx) = self.port_names.iter().position(|name| name == tok) {
                Ok(Val::Port(idx))
            } else {
                Err(format!("invalid operand {tok}"))
            }
        };

        let parse_dst = |tok| match parse_src(tok) {
            // tok = None => parse_src = Err, so unwrap is safe
            Ok(Val::Imm(_)) => Err(format!("cannot write to the literal {}", tok.unwrap())),
            val => val,
        };

        let parse_label = |tok| match tok {
            Some(label) => Ok(label),
            None => Err(format!("{opcode} expects a label")),
        };

        ir.push(match opcode {
            "mv" => Inst::Mv(parse_src(words.next())?, parse_dst(words.next())?),
            "add" => Inst::Add(parse_src(words.next())?, parse_dst(words.next())?),
            "sub" => Inst::Sub(parse_src(words.next())?, parse_dst(words.next())?),
            "mul" => Inst::Mul(parse_src(words.next())?, parse_dst(words.next())?),
            "div" => Inst::Div(parse_src(words.next())?, parse_dst(words.next())?),
            "rem" => Inst::Rem(parse_src(words.next())?, parse_dst(words.next())?),
            "and" => Inst::And(parse_src(words.next())?, parse_dst(words.next())?),
            "or" => Inst::Or(parse_src(words.next())?, parse_dst(words.next())?),
            "j" => Inst::J(parse_label(words.next())?),
            "jez" => Inst::Jez(parse_src(words.next())?, parse_label(words.next())?),
            "jnz" => Inst::Jnz(parse_src(words.next())?, parse_label(words.next())?),
            "jgz" => Inst::Jgz(parse_src(words.next())?, parse_label(words.next())?),
            "jlz" => Inst::Jlz(parse_src(words.next())?, parse_label(words.next())?),
            "jro" => Inst::Jro(parse_src(words.next())?),
            _ => return Err(format!("{opcode} is not an opcode")),
        });

        if let Some(tok) = words.next() {
            return Err(format!("unexpected token {tok}"));
        }
    }

    let len = ir.len();
    let link = |label| match labels.get(label) {
        Some(idx) => Ok(idx % len),
        None => Err(format!("no label {label}")),
    };

    self.program = ir
        .into_iter()
        .map(|inst| -> Result<Inst<usize>, String> {
            Ok(match inst {
                Inst::Mv(src, dst) => Inst::Mv(src, dst),
                Inst::Jez(src, label) => Inst::Jez(src, link(label)?),
            })
        })
        .collect::<Result<_, _>>()?;

    Ok(())
}
```
